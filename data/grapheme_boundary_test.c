/* See LICENSE file for copyright and license details. */
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#include "datautil.h"

struct break_test {
	uint32_t *cp;
	size_t cplen;
	size_t *len;
	size_t lenlen;
	char *descr;
};

static struct break_test *test = NULL;
static size_t ntests = 0;

int
process_line(char **field, size_t nfields, char *comment)
{
	struct break_test *t;
	size_t i;
	char *token;

	if (nfields < 1) {
		return 1;
	}

	/* append new testcase and initialize with zeroes */
	if ((test = realloc(test, ++ntests * sizeof(*test))) == NULL) {
		fprintf(stderr, "realloc: %s\n", strerror(errno));
		return 1;
	}
	t = &test[ntests - 1];
	memset(t, 0, sizeof(*t));

	/* parse testcase "<÷|×> <cp> <÷|×> ... <cp> <÷|×>" */
	for (token = strtok(field[0], " "), i = 0; token != NULL; i++,
	     token = strtok(NULL, " ")) {
		if (i % 2 == 0) {
			/* delimiter */
			if (!strncmp(token, "\xC3\xB7", 2)) { /* UTF-8 */
				/*
				 * '÷' indicates a breakpoint,
				 * the current length is done; allocate
				 * a new length field and set it to 0
				 */
				if ((t->len = realloc(t->len,
				     ++t->lenlen * sizeof(*t->len))) == NULL) {
					fprintf(stderr, "realloc: %s\n",
					        strerror(errno));
					return 1;
				}
				t->len[t->lenlen - 1] = 0;
			} else if (!strncmp(token, "\xC3\x97", 2)) { /* UTF-8 */
				/*
				 * '×' indicates a non-breakpoint, do nothing
				 */
			} else {
				fprintf(stderr, "malformed delimiter '%s'\n",
				        token);
				return 1;
			}
		} else {
			/* add code point to cp-array */
			if ((t->cp = realloc(t->cp, ++t->cplen *
			                     sizeof(*t->cp))) == NULL) {
				fprintf(stderr, "realloc: %s\n", strerror(errno));
				return 1;
			}
			if (cp_parse(token, &t->cp[t->cplen - 1])) {
				return 1;
			}
			if (t->lenlen > 0) {
				t->len[t->lenlen - 1]++;
			}
		}
	}
	if (t->len[t->lenlen - 1] == 0) {
		/* we allocated one more length than we needed */
		t->lenlen--;
	}

	/* store comment */
	if ((test[ntests - 1].descr = strdup(comment)) == NULL) {
		fprintf(stderr, "strdup: %s\n", strerror(errno));
		return 1;
	}

	return 0;
}

int
main(void)
{
	size_t i, j;

	printf("/* Automatically generated by data/gbt */\n"
	       "#include <stdint.h>\n#include <stddef.h>\n\n");

	parse_input(process_line);

	printf("static const struct break_test {\n\tuint32_t *cp;\n"
	       "\tsize_t cplen;\n\tsize_t *len;\n\tsize_t lenlen;\n"
	       "\tchar *descr;\n} t[] = {\n");
	for (i = 0; i < ntests; i++) {
		printf("\t{\n");

		printf("\t\t.cp     = (uint32_t[]){");
		for (j = 0; j < test[i].cplen; j++) {
			printf(" UINT32_C(0x%06X)", test[i].cp[j]);
			if (j + 1 < test[i].cplen) {
				putchar(',');
			}
		}
		printf(" },\n");
		printf("\t\t.cplen  = %zu,\n", test[i].cplen);

		printf("\t\t.len    = (size_t[]){");
		for (j = 0; j < test[i].lenlen; j++) {
			printf(" %zu", test[i].len[j]);
			if (j + 1 < test[i].lenlen) {
				putchar(',');
			}
		}
		printf(" },\n");
		printf("\t\t.lenlen = %zu,\n", test[i].lenlen);

		printf("\t\t.descr  = \"%s\",\n", test[i].descr);

		printf("\t},\n");
	}
	printf("};\n");

	return 0;
}
